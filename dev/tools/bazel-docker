#!/usr/bin/env bash

# Drop-in replacement for Bazel that runs commands in a persistent Docker container.

set -e

# Map the root of the Git repository on the host to the same path inside the container
# so that any build errors include accurate absolute file paths.
repository_root="$(git rev-parse --show-toplevel)"

# Source Bash utilities relative to the root
# in case the user is currently working in a subdirectory.
source "${repository_root}/dev/bash-util.sh"

# Print the static name of the container for the current repository root to stdout.
# Use a separate container for each repository root in case there are multiple Git worktrees.
function bazel-container-name {
  # Combine the basename, for intelligibility, with a hash of the full path, for uniqueness.
  echo "bazel-$(
    basename "$repository_root"
  )-$(
    <<< "$repository_root" sha256sum | head --bytes=7
  )"
}

# The only departure from the standard `bazel` CLI is the addition of a `--name` option,
# which must be supplied by itself,
# and causes the command to simply print the name of the Bazel container for this repository root.
if [[ $# == 1 ]] && [[ "$1" == '--name' ]]
then
  bazel-container-name
  exit
fi

# Run the Bazel command from the same path inside the container
# as the current working directory on the host
# so that relative references like `bazel build :lib` work.
working_directory="$(pwd)"

# Store build outputs in a directory called `_bazel__docker`
# under the appropriate cache path for the platform / user.
# Build outputs are backed by a persistent, named Docker volume.
if [[ "$(uname)" == 'Darwin' ]]; then
  output_root="/private/var/tmp/_bazel__docker"
else
  output_root="${XDG_CACHE_HOME:-"${HOME}/.cache"}/bazel/_bazel__docker"
fi
output_volume='bazel-output-root'

# Make sure that a named container is running.
function ensure-container-running {
  local name="$1"
  local start_command="$2"
  local state="$(docker inspect --format='{{.State.Status}}' "${name}" 2> /dev/null || true)"
  case "$state" in
    'running')
      # The named container is already running. No need to do anything.
      ;;
    'exited')
      log-info "Restarting container ${bold}${name}${reset}"
      if ! docker start "$name" > /dev/null
      then
        log-warn "Removing ${bold}${name}${reset} to start from scratch"
        docker rm "$name" > /dev/null
        $start_command
      fi
      ensure-container-running "$name" "$start_command"
      ;;
    '')
      # The container does not exist. Run it.
      log-info "Starting container ${bold}${name}${reset}"
      $start_command
      ensure-container-running "$name" "$start_command"
      ;;
    *)
      # Handle these situations manually if they arise.
      log-error "Container ${bold}${name}${reset} is in an unexpected state: ${state}"
      exit 1
      ;;
  esac
}

bazel_name="$(bazel-container-name)"
function start-bazel {
  # - Persist the container indefinitely with the appropriate bind-mounts
  #   so we can later run commands on it.
  # - Enable the `NET_ADMIN` capability
  #   so that the tests under `//work/runtime/tests`,
  #   which manage IP addresses on the network device,
  #   can function.
  # - Enable the `SYS_ADMIN` capability and disable secure computing mode
  #   so that end-to-end K8s tests (those under `//e2e`),
  #   which use `unshare` to bind-mount `/etc/hosts` for the life of the test,
  #   can function.
  # - Use as many CPU cores as the system can provide.
  # - Add the canonical hostname `host.docker.internal`
  #   for consistency across platforms.
  #
  # Disabling security measures may look scary,
  # but keep in mind that this tool exists as an alternative to running Bazel directly on the host,
  # where none of these security measures would exist anyway.
  # It's also primarily useful for non-Linux systems (like MacOS),
  # where Docker runs in a VM, which adds an extra layer of isolation.
  docker run \
    --detach \
    --name="$bazel_name" \
    --cap-add=NET_ADMIN \
    --cap-add=SYS_ADMIN \
    --security-opt=seccomp=unconfined \
    --cpus="$(nproc)" \
    --volume="$repository_root":"$repository_root":ro \
    --volume="$output_volume":"$output_root" \
    --volume="${HOME}/.ssh":'/root/.ssh':ro \
    --volume="${HOME}/.kube":'/root/.kube':ro \
    --add-host=host.docker.internal=host-gateway \
    --entrypoint=/usr/bin/sleep \
    gcr.io/bazel-public/bazel:latest \
    'infinity'

  # Install the `uuidgen` CLI tool, which is needed to run a `k8s_cluster_test`.
  # ATTOW there is no obvious pre-built toolchain for Bazel.
  # Don't bother waiting for `apt-get update`; the tool is very stable.
  docker exec \
    --detach \
    --user=0 \
    "$bazel_name" \
    sh -c 'apt-get install --yes uuid-runtime'
}
ensure-container-running "$bazel_name" start-bazel

# Ideally, we would bind-mount the "$output_root" path on the host
# directly to the "$output_root" path in the Bazel container,
# like in https://bazel.build/install/docker-container,
# to have access to built artifacts and test logs after the Bazel container exits.
# While this works fine on Linux, it unfortunately appears subtly broken on Mac.
# Weird failures due to missing files in the analysis phase
# appear to stem from latency issues in both the VirtioFS and gRPC FUSE filesharing systems.
#
# To work around this, mount a simple named volume to the output root on the Bazel container,
# and simultaneously mount that same volume on another container called the "output sync container",
# which runs persistently in the background,
# and whose only purpose is to synchronize the contents of the volume with the host's output root.
output_sync_name='bazel-output-sync'
function start-output-sync {
  docker run \
    --name="$output_sync_name" \
    --detach \
    --volume="$output_volume":'/volume' \
    --volume="$output_root":'/host-output' \
    alpine:latest \
    sh -c 'apk update && apk add unison && unison /volume /host-output -batch -silent -repeat watch -prefer /volume'
}
ensure-container-running "$output_sync_name" start-output-sync

declare -a options

# Tell Docker to allocate a pseudo-TTY if stdout (1) is a pseudo-TTY.
# In that case, Bazel will use formatted output.
if [ -t 1 ]
then
  options+=(--tty)
fi

# Only inherit the `KUBECONFIG` environment variable if it's explicitly set.
if ! [ -z "${KUBECONFIG+.}" ]
then
  # This path would have to exist on the container in order to function,
  # which in practice means it should be either inside the Git repository or under the build root.
  # Warn if that's not the case.
  kubeconfig="$(realpath "$KUBECONFIG")"
  if [[ "$kubeconfig" != "${repository_root}/"* ]] && [[ "$kubeconfig" != "${output_root}/"* ]]
  then
    log-warn "Inheriting ${bold}KUBECONFIG${reset} pointing outside the container: ${bold}${KUBECONFIG}${reset}"
  fi
  options+=(--env=KUBECONFIG="$kubeconfig")
fi

# Run as root within the container
# so that the tests under `//work/runtime/tests`,
# which manage IP addresses on the network device,
# can function.
exec docker exec \
  --user=0 \
  --env=USER=0 \
  --workdir="$working_directory" \
  "${options[@]}" \
  "$bazel_name" \
  bazel --output_user_root="$output_root" "$@"
